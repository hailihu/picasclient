# -*- coding: utf-8 -*-
"""
Created on Mon Jun  4 11:29:47 2012

@author: Jan Bot
"""

# Python imports
import socket
import time

class TokenModifier(object):
    def __init__(self, timeout=86400):
        self.timeout = timeout
    
    def lock(self, key, token):
        raise NotImplementedError("Lock function not implemented.")
    
    def unlock(self, key, token):
        raise NotImplementedError("Unlock functin not implemented.")
    
    def close(self, key, token):
        raise NotImplementedError("Close function not implemented.")
    
    def unclose(self, key, token):
        raise NotImplementedError("Unclose function not implemented.")
    
    def add_output(self,key, token, output):
        raise NotImplementedError("Add_output function not implemented.")
    
    def scrub(self, key, token):
        raise NotImplementedError("Scrub function not implemented.")


class BasicTokenModifier(TokenModifier):
    """Class to manage token modifications with.
    """
    def __init__(self, timeout=86400):
        self.timeout = timeout        
    
    def lock(self, token):
        """Function which modifies the token such that it is locked.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        lock_content = {
            'hostname': socket.gethostname(),
            'lock': int(time.time() ) + self.timeout
        }
        token.update(lock_content)
        return token
    
    def unlock(self, token):
        """Reset the token to its unlocked state.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        lock_content = {
            'hostname': socket.gethostname(),
            'lock': 0
        }
        token.update(lock_content)
        return token
    
    def close(self, token):
        """Function which modifies the token such that it is closed for ever
        to the view that has supplied it.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        done_content = {
            'done': True
        }
        token.update(done_content)
        return token
    
    def unclose(self, token):
        """Reset the token to be fetched again.
        @param key: the key generated by the CouchDB view.
        @param token: the token content.
        @return: modified token.
        """
        done_content = {
            'done': False
        }
        token.update(done_content)
        return token
    
    def add_output(self, token, output):
        """Add the output of the RunActor to the token.
        @param key: the key generated by the CouchDB view.
        @param token: the token content.
        @param output: The output to be included in the token.
        @return: modified token.
        """
        token.update(output)
        return token
    
    def scrub(self, token):
        """Token scrubber: makes sure a token can be handed out again.
        @param key
        @param token
        @return
        """
        if not token.has_key('scrub_count'):
            token['scrub_count'] = 0
        token['scrub_count'] += 1
        return token


class NestedTokenModifier(TokenModifier):
    def __init__(self, timeout=86400):
        self.timeout = timeout
    
    def _get_token_from_list(self, ref, record):
        token = record
        for k in ref[1:]:
            token = token[k]
        return token

    def _get_token_from_value(self, ref, record):
        return record[ref]
    
    def _get_token(self, ref, record):
        if(type(ref) == list):
            return self._get_token_from_list(ref, record)
        else:
            return self._get_token_from_value(ref, record)
    
    def get_token(self, ref, record):
        return self._get_token(ref, record)
    
    def _update_record(self, ref, record, token):
        r = record
        if(type(ref)) == list:
            for k in ref[1:len(ref) -1]:
                r = r[k]
            r[ref[-1]] = token
        else:
            record[ref] = token
        return record
        
    def lock(self, ref, record):
        token = self._get_token(ref, record)
        token['lock'] = int(time.time())
        token['hostname'] = socket.gethostname()
        return self._update_record(ref, record, token)
    
    def unlock(self, ref, record):
        token = self._get_token(ref, record)
        token['lock'] = 0
        return self._update_record(ref, record, token)
    
    def close(self, ref, record):
        token = self._get_token(ref, record)
        token['done'] = int(time.time())
        return self._update_record(ref, record, token)
    
    def unclose(self, ref, record):
        token = self._get_token(ref, record)
        token['lock'] = 0
        token['done'] = 0
        return self._update_record(ref, record, token)
    
    def add_output(self, ref, record, output):
        token = self._get_token(ref, record)
        token['output'].update(output)
        return self._update_record(ref, record, token)
    
    def scrub(self, ref, record):
        token = self._get_token(ref, record)
        token['hostname'] = ""
        token['lock'] = 0
        token['done'] = 0
        token['scrub_count'] += 1
        return self._update_record(ref, record, token)