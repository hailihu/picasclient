# -*- coding: utf-8 -*-
"""
Created on Mon Jun  4 11:29:47 2012

@author: Jan Bot
"""

# Python imports
import socket
import time

class TokenModifier(object):
    def __init__(self, timeout=86400):
        self.timeout = timeout
    
    def lock(self, key, token):
        raise NotImplementedError("Lock function not implemented.")
    
    def unlock(self, key, token):
        raise NotImplementedError("Unlock functin not implemented.")
    
    def close(self, key, token):
        raise NotImplementedError("Close function not implemented.")
    
    def unclose(self, key, token):
        raise NotImplementedError("Unclose function not implemented.")
    
    def add_output(self,key, token, output):
        raise NotImplementedError("Add_output function not implemented.")
    
    def scrub(self, key, token):
        raise NotImplementedError("Scrub function not implemented.")


class BasicTokenModifier(TokenModifier):
    """Class to manage token modifications with.
    """
    def __init__(self, timeout=86400):
        self.timeout = timeout        
    
    def lock(self, token):
        """Function which modifies the token such that it is locked.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        lock_content = {
            'hostname': socket.gethostname(),
            'lock': int(time.time() ) + self.timeout
        }
        token.update(lock_content)
        return token
    
    def unlock(self, token):
        """Reset the token to its unlocked state.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        lock_content = {
            'hostname': socket.gethostname(),
            'lock': 0
        }
        token.update(lock_content)
        return token
    
    def close(self, token):
        """Function which modifies the token such that it is closed for ever
        to the view that has supplied it.
        @param key: the key generated by the couchdb view.
        @param token: the token content.
        @return: modified token.
        """
        done_content = {
            'done': True
        }
        token.update(done_content)
        return token
    
    def unclose(self, token):
        """Reset the token to be fetched again.
        @param key: the key generated by the CouchDB view.
        @param token: the token content.
        @return: modified token.
        """
        done_content = {
            'done': False
        }
        token.update(done_content)
        return token
    
    def add_output(self, token, output):
        """Add the output of the RunActor to the token.
        @param key: the key generated by the CouchDB view.
        @param token: the token content.
        @param output: The output to be included in the token.
        @return: modified token.
        """
        token.update(output)
        return token
    
    def scrub(self, token):
        """Token scrubber: makes sure a token can be handed out again.
        @param key
        @param token
        @return
        """
        if not token.has_key('scrub_count'):
            token['scrub_count'] = 0
        token['scrub_count'] += 1
        return token


class NestedTokenModifier(TokenModifier):
    def __init__(self, token_key, timeout=86400):
        self.token_key = token_key
        self.timeout = timeout
    
    def _get_token(self, record):
        return record[self.token_key]
    
    def _update_record(self, record, token):
        record[self.token_key] = token
        return record
        
    def lock(self, key, record):
        token = self._get_token(record)
        token['lock'] = int(time.time())
        token['hostname'] = socket.gethostname()
        return self._update_record(record, token)
    
    def unlock(self, key, record):
        token = self._get_token(record)
        token['lock'] = 0
        return self._update_record(record, token)
    
    def close(self, key, record):
        token = self._get_token(record)
        token['done'] = int(time.time())
        return self._update_record(record, token)
    
    def unclose(self, key, record):
        token = self._get_token(record)
        token['lock'] = 0
        token['done'] = 0
        return self._update_record(record, token)
    
    def add_output(self,key, record, output):
        token = self._get_token(record)
        token['output'].update(output)
        return self._update_record(record, token)
    
    def scrub(self, key, record):
        token = self._get_token(record)
        token['lock'] = 0
        token['done'] = 0
        token['scrub_count'] += 1
        return self._update_record(record, token)